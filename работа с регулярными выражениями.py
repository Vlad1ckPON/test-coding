import re
#  так импортирубтся регулярные выраждения
# pattern  = r'egg'
# регулярная переменная

# if re.match(pattern, 'eggspam'):
#     print("match")
# else:
#     print("lol")
    #  match ищет совпадение в начале строки
    
    
# match = re.search(pattern, "akldshjnfouh")
# ищет элементы в любом месте строки
# match1 = re.findall(pattern, "dfasdiofh")
# возращает как строку все совпадения



"""метасимволы"""
#  . - любой знак, ^ - определенный ознак в начале, $ - опеределенный знак в конце
# import re
# pattern = r"^gr.y$"
# if re.match(pattern, "grey"):
#     print('Так можно сделать')
# elif re.match(pattern, "gray"):
#     print("Так тоже можно")
# elif re.match(pattern, "white"):
#     print('А вот так уже нет')
#  тоесть можно например написать огромный массив данных, и с помощью метасимволов, например найти среди всех элементов номер телефона))

# print(160 / 729 * 0.9)

"""классы метасимволов"""
#  [a-z] означает все прописные буквы с a до z, соответсвенно [0-9] означает все цифры
#  $ - означает все символы , кроме символов класса
# ^ тоже самое означате и этот символ, только когда он стоит в начале
# *, +, ?, {} - * означает ноль или более упоминания обьекта поиска, + - тоже самое, только ноль или более упоминаний обьекта
# ? - ноль или одно повторение
#  {} - означает последовательность, например чтобы написать последовательность от 0 до 10 {0, 10}

"""группы """
#  () - может быть атрибутом метасимволов, например * или ?. Есть и специальные методы group() или group(0) - возвращает все найденные совпадения 
#  группы - именнованные и незахватывающие. именованные пример name - логично, имя группы, а A содержание группы
# pattern = r"(?p<name>a)"
# незахватывающие группы пишутся так
# pattern = r"(?:def)"
#  метасимвол | - означает или 
#  специальные последовательности от одного до 100 будет
#  например \1 или \90
#  для чего можно использовать
# pattern = r"(.+) \1"
#  это означает, что любые символы могут повториться после пробела
#  есть и другие специальные последовательности - \w, \s, \d, - символы слов, пробелы и цифры
# но если их записать в ввехнем регистре, то они будут значить противоположное
#  \A, \Z и \b- начало строки, конец строки, словораздел
#  \b можно использовать для разделение слов, вот так
# pattern = r"\b(cat)\b"
# match = "This is cat"
#  [\w.-]+ - будет означать одному или более символу слова, точке или черточке
#  чтобы например отделить почту, нужно написать такой паттерн

"""Регулярки"""
text = "В 18 веке Россия прошла через множество важных событий, которые оказали сильное влияние на ее историю. Одним из наиболее значимых моментов стало основание Санкт-Петербурга в 1703 году, которое стало новой столицей и центром европейской культуры. В 1721 году Петр I провозгласил себя императором Российской империи, а к 1762 году на трон пришла Екатерина II. В 1773-1775 годах произошло восстание Пугачева против Екатерины II, а в 1785 году был учрежден Одесский порт. 1799 год стал годом коронации Павла I, который был покушен и убит незадолго до того, как начался 19 век. Все эти события определили траекторию развития России и сильно повлияли на ее будущее."


text2 = "Знаки препинания в русском языке являются важным элементом грамматики, которые помогают понимать смысл и правильно интонационно читать предложения. Запятая обозначает краткую паузу, точка - конец предложения, восклицательный и вопросительный знаки выражают эмоции. Необходимо уметь использовать знаки препинания правильно, чтобы избегать ложных смыслов и сбивчивости высказываний."

info = "10 EUR 20 EUR 30 EUR - EURO EUROPE"

years = re.findall(r"\d{4}", text)

periods = re.findall(r"\d{4}-\d{4}", text)

result = re.sub(r'\bEUR\b', "USD", info)

words = re.split(r"\W+", text2)

print(words)
print(result)
print(years)
print(periods)