"""LEGB - rule
    l - local 
    E - enclosed
    G - global
    B - builtins"""
#  тоесть, когда ты работаешь с переменной, ее поиск начинаеться сверху вниз или же с local по builtins, или к самому близкому к взаимодействию с переменной
# import builtins


# builtins.scope = "builtins"
# scope = "global"
# def outer():
#     scope = "enclosed"
#     def inner():
#         scope = "local"
#         print(scope)
#     inner()
    
# if __name__ == "__main__":
#     outer()
    # если убрать scope во внутренней функции, то он выведет enclosed, если убрать scope во внешней функции, то global, а если оставить так, то local, а если убрать все кроме функции bultins - то будет builtins, ну все же если ничего нет под именем переменной, то выдаст ошибку NameError
    
"""global  и nonlocal """
# global и nonlocal нужны, когда нужно изменить переменную, но если нужно просто вывести, то там работает замыкание, кроме ситуаций, когда у нас есть две переменные с одним название, одна в глобальном скоупе, а другая во внешней функции
# global дает понять, что нужно искать переменную не по правилу LEGB-rule, а в глобальном скоупе
# также с помощью global, можно создать переменную в глобальном скоупе, если ее там нет
# nonlocal работает также, только ищет  во внешних скоупах, а не в глобальных
#  но не стоит злоупотреблять глобалки, так как потом, когда будут настоящие модули с огромным количеством кода и функций, и каждый раз переменная будет менятся, то будет очень сложно отследить где и когда она так или иначе поменялась - это основная проблема глобализма
# count = 0


# def plus():
#     count = 100
    
#     def inner():
#         global count
#         count += 1
#         print(count) 
        # выведет 0
    # inner()
    
# def plus1():
#     count = 100
    
#     def inner():
#         nonlocal count
#         count += 1
#         print(count) 
        # выведет 100
#     inner()
    
# def plus2(x):
#         x += 1
#         print(x) 
        #  просто передачу аргумента при вызове функции, решает проблему глобализма
        # + ее можно использовать неограниченное количество раз
        # старайся писать такие функции, это основа функционального программирования

# if __name__ == "__main__":
#    plus()
#    plus1()
#    counter = plus2(count)