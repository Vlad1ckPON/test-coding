# Сортировка пузырьком
# просто поэтапно сравнивает левый и правый элементы массив, если левый больше, то он их меняет на правый
# и так несколько итераций пока все элементы массива не встанут на свои места
def bubble_sort(nums):
    
    if len(nums) <= 1:
        return nums
    
    swapped = True
    
    while swapped:
        swapped = False
        
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i+ 1], nums[i]
                swapped = True
        
    return nums
         

# Сортировка Хоара(быстрая сортировка)
# Берется любой элемент(я взял средний, но в целом можно и первый), и методом сравнений получаются два подмассива(выбранный элемент никак трогается) - в одном все элементы меньше выбранного, а вдругом наоборот, и они рекурсивно сортируются этим же алгоритмом(хотя можно и другими, но это уже будут модификации, то есть можно например их отсортировать вставками), а в итоге мы получаем отсортированный массив
def quick_sort(nums):
    
    if len(nums) < 2:
        return nums
    
    pivot = nums[len(nums) // 2]
    
    left = [e for e in nums if e < pivot]
    right = [e for e in nums if e > pivot]
    
    return ( quick_sort(left) +
            [e for e in nums if e == pivot] + 
            quick_sort(right)
            
            )
    
    
# Сортировка выбором



# Бинарный поиск
# Берется среднее число, если оно равно числу, которое мы ищем, то алгоритм выполнился, т.к. мы нашли число, если число меньше, то мы отрезаем от массива все правые числа от этого элемента, и находим средний элемент уже нового массива, и так далее пока не найдем элемент



def binary_search(nums, target):
    
    new_nums = quick_sort(nums)
    
    if len(nums) <= 1:
        return nums
    
    left = 0
    right = len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        guess = new_nums[mid]
        
        if guess == target:
            return f"Вы нашли число {target}, под индексом {nums.index(target)}"
        
        if guess > target:
            right = mid - 1
            
        else:
            left = mid + 1
            
    return f"Вы не нашли число"


# Линейный поиск
# Просто сравнивается каждое число с числом, которое мы ищем
def linear_search(nums: list[int], target) -> str:
    low = 0
    result = False
    
    while low < len(nums) and not result:
        if nums[low] == target:
            result = True
            return f"В этом массиве есть число {target}, под индексом {nums.index(target)}"
        else:
            low += 1
    return f"В этом массиве нет числа {target}"

    # for num in nums:
    #     if num == target:
    #         return target
    #     else:
    #         next(nums)
    # return -1
    
# Рекурсия 
# По сути это функция, которое в процессе выполнение выполняет себя столько раз, пока не будет собдюдено условие
# Я рассматрю на примере числа Фибоначчи
# Число Фибоначчи - последовательность, которая начинается с 0 и 1, а следующие числа являются суммой двух предыдущих
# В этом алгоритме очень сильно вписовается рекурсия, т.к. нам надо каждый раз считать

def fib(n):
    if n in (1, 2):
        return 1
    return fib(n - 1) + fib(n - 2)

def fact(num):
    if num <= 1:
        return num
    else:
        return num  * fact(num - 1)
    

# алгоритмы поиска путей в графе

# Bfs - алгоритм для поиска оптимальных путей в незвешенном графе(меньше всего сегментов), 
# работает так: в очередь типа FIFO добавляется узел, и если его нет в сет уже посещенных узлов, то алгортим идет 
# к соседнему узлу, и так далее пока он не найдет нужный узел 
# Он называется поиск в ширину, потому что сначала проходит по первостепенным узлам, потом по второстепенным и тд - то есть в ширину

from collections import deque

def bfs(start: int, target: int, graph: dict[int]) -> bool:
    pass

# Dfs - алгоритм, который просто ищет любой путь в невзвешенном графе
# Его реализация рекурсивная, поэтому там используется стек,
#  и работает он так: основная часть - мы проверяем является ли узел искомым(True), и проверяем есть и он в массиве уже посещенных(False),
# рекурсивная часть - ищем соседа этого узла, и если в проверка возвращается True, возвращаем тоже самое, если нет, заново, 
# пока не найдем нужный узел
# Он называется поиск в глубину, потому что просто ищет соседние узлы

def dfs(start: int, target: int, graph: dict[int], visited: list[int]):
    if start == target:
        return True
    
    if start in visited:
        return False
    
    visited += [start]
    for neighbor in graph[start]:
        if neighbor not in visited:
            if dfs(neighbor, target, graph, visited):
                return True
    return False
    
# Алгоритм Дейкстры - алгоритм поиска оптимального пути в взвешенном графе
# работает он так: он создает несколько словарей: словарь под длину пути(вначале он будет бесконченость для всех ребер, 
# кроме первого, он будте 0), словарь родителей узлов(вначале -1 для всех узлов, потому мы их еще не исследовали),
# и очередь(работает парой - вес и узел), после он будет перезаписыпать пути до узлов, если он короче уже исседованных, 
# и заполнять словарь с родителя